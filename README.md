## 인프런 도커 강의
[LINK](https://www.inflearn.com/course/%EB%94%B0%EB%9D%BC%ED%95%98%EB%A9%B0-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EB%8F%84%EC%BB%A4-ci)

---
# 도커를 쓰는 이유
프로그램을 다운받는 과정을 간단하게 만들기 위해서

도커 없이 프로그램을 받을 때는
Installer 다운로드 -> Installer 실행 -> 프로그램 설치완료
- 서버, 패키지 버전, 운영체제 등등에 따라 프로그램을 설치하는 과정 중에 에러가 발생함, 설치 과정이 복잡함

- Redis 다운로드 예제
- 도커가 없는 경우 :  Redis 홈페이지 이동 -> redis.io -> install
- 도커가 있는 경우 : `docker run -it redis` : 바로 다운로드
- 설치 과정이 훨씬 간단해짐

# 도커란 무엇인가?
- 컨테이너를 사용하여 응용프로그램을 더 쉽게 만들고 배포하고 실행할 수 있도록 설계된 도구이며 `컨테이너 기반의 오픈소스 가상화 플랫폼이며 생태계`

> 컨테이너란?
> - 안에 다양한 프로그램, 실행환경을 컨테이너로 추상화하고 동일한 인터페이스를 제공하여 `프로그램의 배포 및 관리 단순화`
> - 클라우드 환경에서도 실행 가능


# 도커 이미지와 컨테이너 정의
#### 컨테이너
- 코드와 모든 종속성을 패키지화하여 응용 프로그램이 한 컴퓨팅 환경에서 `다른 컴퓨팅 환경으로 빠르고 안정적으로 실행되도록 하는 소프트웨어의 표준 단위`

#### 컨테이너 이미지
- 코드, 런타임, 시스템 도구, 시스템 라이브러리 및 설정과 같은 응용 프로그램을 실행하는데 필요한 모든 것 포함하는 `실행 가능한 소프트웨어 패키지`
- 런타임에 컨테이너가 되고 도커 컨테이너의 경우 도커 엔진에서 실행될 때 이미지가 컨테이너가 됨.
- 인프라에 관계없이 항상 동일하게 실행됨
- 컨테이너는 소프트웨어를 환경으로부터 격리시키고 `개발과 스테이징 차이가 있어도 균일하게 작동하도록 보장`

---

# Docker 설치
[설치 링크](docker.com)
자신의 운영체제에 맞는 도커 버전을 설치하고 로그인까지 완료한다.
맥 기준 `terminal`에서 `docker version`을 입력하면 설치를 확인할 수 있다.

# 도커 사용
### 주의점
- 도커 CLI에 커맨드 입력
- 입력 후 도커 서버에서 커맨드를 받아 이미지 생성 / 컨테이너 작업을 실행
- 이미지가 없는 경우에는 `Unable to find image...`의 문구가 출력된다.
- 도커 허브까지 도달하기 전에 캐시 영역에 있다면 가져온다.
- 캐싱된 이미지에 대해서는 바로 프로그램이 실행된다.

## 도커와 이전 기술의 차이점
### 이전
- 한 대의 서버를 한 용도로만 사용 -> 남는 공간 방치
- 안정적이지만 비효율적

### 하이퍼바이저 기반 가상화
- 논리적으로 공간분할하여 VM이라는 가상 환경의 서버 이용
- 호스트 시스템에서 다수의 게스트 OS를 구동하여 VM을 모니터링하는 `중간 관리자`

> 도커 컨테이너와 VM
> - 공통점 : 기본 하드웨어에서 격리된 환경 내 애플리케이션 방치
> - 차이점 : 격리된 환경을 얼마나 격리시키는가 (컨테이너는 하이퍼바이저와 게스트가 필요하지 않아 오버헤드가 적음)

## 컨테이너 논리적 분리
1. C Group
   - CPU, 메모리, 네트워크 등 프로세스 그룹의 시스템 리소스 사용량 관리
2. 네임스페이스
   - 하나의 시스템에서 프로세스를 격리시킬 수 있는 가상화 기술
   - 별개의 독립된 공간을 사용하는 것처럼 격리된 환경을 제공하는 경량 프로세스 가상화 기술

> 도커 환경에서 사용 가능한 이유
> - 터미널 실행 후 도커 버전을 확인 -> OS가 `linux`로 출력
> - 내부적으로 컨테이너 부분은 리눅스 VM이 깔려 있어 도커 클라이언트/서버는 리눅스 환경에서 실행 

---

# 이미지로 컨테이너 만들기
- 이미지는 응용 프로그램이 실행되는데 필요한 모든 내용을 가짐
  - 컨테이너가 시작 될 때 실행되는 명령어 `run`
  - 파일 스냅샷 `실행 파일` : 디렉토리나 파일을 복사한 것


## 이미지 생성 순서
1. Docker 클라이언트에 `docker run [image]` 입력
2. 도커 이미지에 있는 파일 스냅샷을 하드디스크로 이동
3. 이미지에서 가지고 있는 명령어를 사용하여 프로그램 실행

## 클라이언트 명령어
- 실행중인 프로세스 확인하는 명령어
1. docker : docker 클라이언트에 언급
2. ps : process status 줄임

- 확인 방법 : 2개의 터미널을 사용하여 한 터미널에서는 컨테이너의 실행, 다른 하나는 상태를 확인한다.
- 컨테이너 아이디, 이미지, 생성시간 등 컨테이너에 대한 `메타 데이터`를 확인할 수 있다.

## 컨테이너 생명주기
- 생성(create) - 시작(start) - 실행(run) - 중지(stop) - 삭제(rm)

1. `docker create hello-world`
   - 생성된 컨테이너의 id 확인 가 (파일 스냅샷 생성)
2. `docker start -a [container ID]`
   - `-a` : attach, ID의 일부만 입력해도 자동으로 실행됨. docker 컨테이너의 아웃풋을 화면에 표시함
3. `stop` : 기존 실행중인 내역 종료 후 컨테이너 종료(SIGTERM) `kill` : 기존 실행중인 내역이 있어도 바로 중단
4. ```shell
   docker rm `docker ps -a -q` # 모든 컨테이너 삭제
   docker rmi [image ID] # 모든 이미지 삭제
   ```
   
## 실행 중인 컨테이너에 명령어 전달
`docker exec [container ID] [명령어]`

# REDIS
- 레디스 서버가 작동중인 상태에서 레디스 클라이언트로 명령어를 서버에 전달

1. `docker run redis` : 레디스 서버 실행
2. 새 터미널에서 `redis-cli` 실행 시 오류 : 레디스 서버 밖에서 실행했기 때문에 에러 발생
   - 레디스 클라이언트도 컨테이너 안에서 실행해야 함
3. `docker exec -it [container ID] redis-cli`
   - 실행 전에 `docker ps` 명령어로 동작중인 redis 서버의 id 확인 가능
   - `-it` 명령어가 있어야 실행 후 계속 명령어 작성 가능 (interactive terminal)
- 컨테이너에 명령을 전달할 때 터미널로 접속하는 방법 : 명령어 부분에 `sh` 입력


   